<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE syntax SYSTEM "syntax.dtd">
<syntax>
	<!-- STUDIO - Completely rewritten for Coda, do not replace with SEE version -->
	<head>
		<name>CFML</name> <!-- The definitions title -->
		<charsintokens><![CDATA[_0987654321abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-@"]]></charsintokens> 
		<charsincompletion><![CDATA[_0987654321abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-@</=!>]]></charsincompletion> 
		<folding toplevel="3" />
	</head>

	<states>

		<default id="Base" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" usespellchecking="yes" scope="meta.default">

			<import mode="XML" keywords-only="yes"/>

			<state id="Inline CFML Script" delimiterState="Tags" useforautocomplete="no" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" foldable="yes" scope="meta.default">
				<begin><regex>&lt;\s*(?i)cfscript\s*></regex><autoend>&lt;/cfscript></autoend></begin>
				<end><regex>&lt;\s*/\s*(?i)cfscript\s*></regex></end>

				<import state="CFML Code" />

			</state>

			<state id="CFML Comment" type="comment" foldable="yes" scope="markup.comment">
				<begin><regex>&lt;!---</regex></begin>
				<end><regex>---&gt;</regex></end>
				<state-link state="CFML Comment" mode="CFML" />
			</state>

			<state-link state="Comment" mode="XML" />
			<state-link state="CDATA" mode="XML" />
			<state-link state="Doctype" mode="XML" />
			<state-link state="Escape" mode="XML" />

			<state id="CFML Query" delimiterState="CFML Tags" usesymbolsfrommode="SQL" useautocompletefrommode="SQL" foldable="yes" scope="meta.default">
				<begin><regex>&lt;(?i)\s*cfquery.*?></regex></begin>
				<end><regex>&lt;\s*/\s*(?i)cfquery\s*></regex></end>

				<import mode="SQL" keywords-only="yes"/>
				<!--<state-link state="CFML Code" />-->
				
				<state-link state="CFML Comment" />
				<state-link state="Comment" mode="XML" />
				<state-link state="CDATA" mode="XML" />
				<state-link state="Doctype" mode="XML" />
				<state-link state="Escape" mode="XML" />

				<import state="CFML Tags" />

				<!-- CODA -->
				<state id="Query Comment" type="comment" foldable="yes" scope="comment.block">
					<begin><regex>/\*</regex></begin>
					<end><regex>\*/</regex></end>
				</state>

			</state>

			<state-link state="Block" />

			<state id="CFML Code" useforautocomplete="no" containerState="yes" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" scope="meta.default">
			
				<keywords id="Generic Functions" useforautocomplete="no" scope="language.function">
					<!--<regex>([\w]+[\(]{1}[\w\s\.\[\]\)\(\"/;,|#&amp;]+[\)]{1})(?=[^&lt;]*&gt;)</regex>-->
					<regex>([A-Za-z0-9_]+\s*)\(</regex>
				</keywords>
			
				<state id="Single Line Comment" type="comment" scope="comment.line">
					<begin><regex>//</regex></begin>
					<end><regex>[\n\r]</regex></end>
				</state>
			
				<state id="Multi Line Comment" type="comment" foldable="yes" scope="comment.block">
					<begin><regex>/\*</regex></begin>
					<end><regex>\*/</regex></end>
				</state>
			
				<state id="CFML Double Strings" type="string" useforautocomplete="no" scope="string.double">
					<begin><regex>"</regex></begin>
					<end><regex>"</regex></end>
					<import state="CFML Output Variables State" keywords-only="yes"/>
				</state>
			
				<state id="CFML Single Strings" type="string" useforautocomplete="no" usespellchecking="yes" scope="string.single">
					<begin><regex>'</regex></begin>
					<end><regex>'</regex></end>
					<import state="CFML Output Variables State" keywords-only="yes"/>
				</state>
			
				<state id="Block" type="block" foldable="yes" scope="meta.block.curly">
					<!--<begin><regex>(?:(?&lt;=\s)(?:if|else|else\s+if|for|while|do|switch|case)\s*(?:\([^#{\n\r]*?\))?)?\s*{</regex></begin>-->
					<begin><regex>{</regex></begin>
					<end><regex>}</regex></end>
					<import state="CFML Code" />
					<import state="CFML Output Variables State" keywords-only="yes"/>
				</state>
			
				<state-link state="CFML Output Variables State" />

				<keywords id="Control Keywords" useforautocomplete="yes" scope="keyword.control">
					<string>assignment</string>
					<string>break</string>
					<string>case</string>
					<string>catch</string>
					<string>continue</string>
					<string>default</string>
					<string>do</string>
					<string>else</string>
					<string>elseif</string>
					<string>for</string>
					<string>if</string>
					<string>in</string>
					<string>switch</string>
					<string>try</string>
					<string>while</string>
					<string>function</string>
				</keywords>
						
				<keywords id="Scope and Tag Variables" useforautocomplete="no" scope="keyword">
					<regex>((?i)(?:session\.|application\.|request\.|request\.session\.|client\.|server\.|server\.coldfusion\.|form\.|cfcatch\.|cfdirectory\.|cferror\.|cffile\.|cfftp\.|cfhttp\.|cfindex\.|cfldap\.|cfpop\.|cfquery\.|cfregistry\.|cfsearch\.|cfstoredproc\.|cgi\.|url\.|cookie\.|arguments\.|cfevent\.)(?:[\w\d])+(?:\[([\w\d"'])+\])?)</regex>
				</keywords>
			
				<keywords id="Numbers" useforautocomplete="no" scope="constant.numeric">
					<regex>(?&lt;=[^\w\d]|^)((?:(?:(?:[0-9]+\.[0-9]*)|(?:\.[0-9]+))(?:[eE][+\-]?[0-9]+)?[fFlL]?)|(?:(?:(?:[1-9][0-9]*)|0[0-7]*|(0[xX][0-9a-fA-F]+))(?:(?:[uU][lL]?)|(?:[lL][uU]?))?))(?=[^\w\d]|$)</regex>
				</keywords>
			
				<keywords id="Keywords" casesensitive="no" useforautocomplete="yes" scope="keyword">
					<string>and</string>
					<string>or</string>
					<string>mod</string>
					<string>is</string>
					<string>equal</string>
					<string>eq</string>
					<string>lt</string>
					<string>less than</string>
					<string>lte</string>
					<string>le</string>
					<string>less than or equal to</string>
					<string>gt</string>
					<string>greater than</string>
					<string>gte</string>
					<string>greater than or equal to</string>
					<string>is not</string>
					<string>neq</string>
					<string>not equal</string>
					<string>contains</string>
					<string>does not contain</string>
					<string>not</string>
					<string>true</string>
					<string>false</string>
					<string>&amp;</string>
					<string>catch</string>
					<string>continue</string>
					<string>return</string>
					<string>var</string>
				</keywords>
			
				<keywords id="Functions" casesensitive="no" useforautocomplete="yes" scope="support.function">
					<regex>((?i)[^\w\d]ACos)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ASin)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Abs)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]AddSOAPRequestHeader)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]AddSOAPResponseHeader)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]AjaxLink)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]AjaxOnLoad)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ApplicationStop)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayAppend)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayAvg)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayClear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayContains)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayDelete)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayDeleteAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayFind)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayFindNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayInsertAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayIsDefined)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayIsEmpty)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayLen)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayMax)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayMin)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayPrepend)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayResize)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArraySet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArraySort)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArraySum)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArraySwap)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ArrayToList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Asc)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Atn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BinaryDecode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BinaryEncode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitAnd)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitMaskClear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitMaskRead)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitMaskSet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitNot)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitOr)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitSHLN)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitSHRN)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]BitXor)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CJustify)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheGet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheGetAllIds)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheGetMetadata)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheGetProperties)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CachePut)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheRemove)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CacheSetProperties)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Ceiling)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CharsetDecode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CharsetEncode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Chr)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Compare)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CompareNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Cos)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateDate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateDateTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateODBCDate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateODBCDateTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateODBCTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateObject)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateTimeSpan)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]CreateUUID)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DE)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DateAdd)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DateCompare)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DateConvert)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DateDiff)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DateFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DatePart)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Day)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DayOfWeek)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DayOfWeekAsString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DayOfYear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DaysInMonth)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DaysInYear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DecimalFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DecrementValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Decrypt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DecryptBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DeleteClientVariable)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DeserializeJSON)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DirectoryCreate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DirectoryDelete)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DirectoryExists)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DirectoryList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DirectoryRename)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DollarFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]DotNetToCFType)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Duplicate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Encrypt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EncryptBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityDelete)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityLoad)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityLoadByExample)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityLoadByPK)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityMerge)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntityReload)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntitySave)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]EntitytoQuery)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Evaluate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Exp)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ExpandPath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileClose)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileCopy)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileDelete)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileExists)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileIsEOF)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileMove)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileOpen)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileRead)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileReadBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileReadLine)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileSeek)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileSetAccessMode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileSetAttribute)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileSetLastModified)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileSkipBytes)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileWrite)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FileWriteLine)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Find)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FindNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FindOneOf)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FirstDayOfMonth)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Fix)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]FormatBaseN)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GenerateSecretKey)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetAuthUser)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetBaseTagData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetBaseTagList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetBaseTemplatePath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetClientVariablesList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetComponentMetaData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetContextRoot)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetCurrentTemplatePath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetDirectoryFromPath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetEncoding)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetException)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetFileFromPath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetFileInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetFunctionCalledName)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetFunctionList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetGatewayHelper)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetHttpRequestData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetHttpTimeString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetK2ServerDocCount)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetK2ServerDocCountLimit)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetLocalHostIP)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetLocale)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetLocaleDisplayName)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetMetaData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetMetricData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetPageContext)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetPrinterInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetProfileSections)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetProfileString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetReadableImageFormats)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetSOAPRequest)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetSOAPRequestHeader)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetSOAPResponse)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetSOAPResponseHeader)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetTempDirectory)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetTempFile)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetTemplatePath)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetTickCount)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetTimeZoneInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetToken)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetUserRoles)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetVFSMetaData)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]GetWriteableImageFormats)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]HTMLCodeFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]HTMLEditFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Hash)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Hour)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IIf)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageAddBorder)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageBlur)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageClearRect)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageCopy)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageCrop)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawArc)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawBeveledRect)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawCubicCurve)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawLine)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawLines)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawOval)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawPoint)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawQuadraticCurve)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawRect)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawRoundRect)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageDrawText)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageFlip)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetBlob)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetBufferedImage)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetEXIFTag)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetHeight)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetIPTCTag)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGetWidth)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageGrayscale)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageNegative)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageOverlay)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImagePaste)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageRead)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageReadBase64)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageResize)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageRotate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageRotateDrawingAxis)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageScaleToFit)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSetAntialiasing)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSetBackgroundColor)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSetDrawingColor)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSetDrawingStroke)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSetDrawingTransparency)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageSharpen)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageShear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageShearDrawingAxis)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageTranslate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageTranslateDrawingAxis)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageWrite)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageWriteBase64)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ImageXORDrawingMode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IncrementValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]InputBaseN)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Insert)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Int)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsArray)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsBoolean)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsCustomFunction)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsDDX)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsDate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsDebugMode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsDefined)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsIPv6)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsImage)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsImageFile)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsInstanceOf)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsJSON)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsK2ServerABroker)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsK2ServerDocCountExceeded)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsK2ServerOnline)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsLeapYear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsLocalHost)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsNull)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsNumeric)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsNumericDate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsObject)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsPDFFile)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsPDFObject)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsQuery)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsSOAPRequest)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsSimpleValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsSpreadsheetFile)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsSpreadsheetObject)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsStruct)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsUserInAnyRole)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsUserInRole)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsUserLoggedIn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsValid)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsWDDX)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXML)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXmlAttribute)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXmlDoc)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXmlElem)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXmlNode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]IsXmlRoot)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]JSStringFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]JavaCast)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LJustify)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSCurrencyFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSDateFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSEuroCurrencyFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSIsCurrency)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSIsDate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSIsNumeric)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSNumberFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSParseCurrency)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSParseDateTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSParseEuroCurrency)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSParseNumber)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LSTimeFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]LTrim)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Left)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Len)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListAppend)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListChangeDelims)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListContains)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListContainsNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListDeleteAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListFind)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListFindNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListFirst)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListGetAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListInsertAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListLast)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListLen)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListPrepend)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListQualify)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListRest)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListSetAt)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListSort)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListToArray)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListValueCount)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ListValueCountNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Location)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Log)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Log10)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Max)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Mid)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Min)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Minute)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Month)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]MonthAsString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Now)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]NumberFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMClearSession)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMCloseSession)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMEvictCollection)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMEvictEntity)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMEvictQueries)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMExecuteQuery)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMFlush)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMGetSession)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMGetSessionFactory)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ORMReload)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ObjectEquals)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ObjectLoad)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ObjectSave)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ParagraphFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ParseDateTime)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Pi)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]PrecisionEvaluate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]PreserveSingleQuotes)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Quarter)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QueryAddColumn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QueryAddRow)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QueryConvertForGrid)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QueryNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QuerySetCell)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]QuotedValueList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REFind)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REFindNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REMatch)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REMatchNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REReplace)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]REReplaceNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]RJustify)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]RTrim)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Rand)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]RandRange)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Randomize)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ReleaseComObject)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]RemoveChars)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]RepeatString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Replace)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ReplaceList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ReplaceNoCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Reverse)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Right)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Round)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Second)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SendGatewayMessage)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SerializeJSON)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SetEncoding)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SetLocale)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SetProfileString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SetVariable)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Sgn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Sin)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Sleep)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpanExcluding)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpanIncluding)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddColumn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddFreezePane)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddImage)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddRow)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddRows)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetAddSplitPane)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetCreateSheet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetDeleteColumn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetDeleteColumns)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetDeleteRow)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetDeleteRows)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetFormatCell)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetFormatColumn)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetFormatColumns)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetFormatRow)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetFormatRows)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetGetCellComment)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetGetCellFormula)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetGetCellValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetInfo)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetMergeCells)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetRead)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetReadBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetActiveSheet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetActiveSheetNumber)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetCellComment)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetCellFormula)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetCellValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetColumnWidth)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetFooter)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetHeader)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetSetRowHeight)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetShiftColumns)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetShiftRows)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]SpreadsheetWrite)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Sqr)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StripCR)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructAppend)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructClear)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructCopy)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructCount)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructDelete)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructFind)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructFindKey)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructFindValue)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructGet)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructInsert)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructIsEmpty)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructKeyArray)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructKeyExists)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructKeyList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructSort)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]StructUpdate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Tan)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ThreadJoin)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ThreadTerminate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Throw)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]TimeFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ToBase64)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ToBinary)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ToScript)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ToString)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Trace)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]TransactionCommit)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]TransactionRollback)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]TransactionSetSavePoint)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]TransactionSetSavePoint)(?=\s*\()</regex>				
					<regex>((?i)[^\w\d]Trim)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]UCase)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]URLDecode)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]URLEncodedFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]URLSessionFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Val)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]ValueList)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]VerifyClient)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Week)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Wrap)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]WriteDump)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]WriteLog)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]WriteOutput)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Writedump)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Writelog)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlChildPos)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlElemNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlFormat)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlGetNodeType)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlNew)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlParse)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlSearch)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlTransform)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]XmlValidate)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]Year)(?=\s*\()</regex>
					<regex>((?i)[^\w\d]YesNoFormat)(?=\s*\()</regex>
				</keywords>
			
				<keywords id="Operators" useforautocomplete="no" scope="language.operator">
					<regex>([\+\-\*\\\=])</regex>
				</keywords>
			
			</state>
			
			<state id="CFML Output Variables State" containerState="yes" scope="meta.default">
				<keywords useforautocomplete="no" scope="language.variable">
					<regex>(#[^&lt;&gt;\{#]+#)</regex>
				</keywords>
			</state>

			<state id="Inline CSS" delimiterState="Tags" usesymbolsfrommode="CSS" useautocompletefrommode="CSS" foldable="yes" indent="yes" scope="meta.block.css">
				<begin>
					<regex>&lt;[ \t]*(?i)style[^>]*></regex>
					<autoend>&lt;/style></autoend>
				</begin>
				<end>
					<regex>(?i)&lt;[ \t]*/[ \t]*style[ \t]*></regex>
				</end>

				<import mode="CSS"/>

			</state>

			<state id="JavaScript Container" containerState="yes" usesymbolsfrommode="JavaScript" useautocompletefrommode="JavaScript" scope="meta.block.js">
				<import mode="JavaScript" keywords-only="yes"/>
				<state-link state="AutodocComment" mode="JavaScript"/>
				<state-link state="Comment" mode="JavaScript"/>
				<state-link state="Regular Expressions" mode="JavaScript"/>
				<state-link state="String" mode="JavaScript"/>
				<state-link state="SingleString" mode="JavaScript"/>
			</state>

			<state id="Inline JavaScript" delimiterState="Tags" usesymbolsfrommode="JavaScript" useautocompletefrommode="JavaScript" foldable="yes" scope="meta.block.js">
				<begin>
                    <regex>(?:&lt;[ \t]*(?i)script\s*?>)|(?:&lt;(?i)script.+?javascript.*?(?&lt;![-])>)</regex>
					<autoend>&lt;/script></autoend>
				</begin>
				<end>
					<regex>&lt;(?i)/script[^>]*></regex>
				</end>
					
				<import mode="JavaScript"/>
   				<import state="CFML Output Variables State" keywords-only="yes" />
			</state>

			<state id="Self Closing Tags" foldable="no" scope="markup.tag">
            	<begin>
                    <regex>&lt;[ \t]*(?i)(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)</regex>
                </begin>
                <end>
                    <regex>&gt;</regex>
                </end>

                <import state="Tags"/>
				<import state="CFML Output Variables State" keywords-only="yes"/>
            </state>


			<state id="Foldable CFML Tags" containerState="yes" delimiterState="CFML Tags" foldBegin="\A&lt;[ \t]*(?'cfmltagstatename'[Cc][Ff](?:[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]|[Ii][Ff]|[Ll][Oo][Oo][Pp]|[Oo][Uu][Tt][Pp][Uu][Tt]|[Cc][Aa][Ss][Ee]|[Dd][Ee][Ff][Aa][Uu][Ll][Tt][Cc][Aa][Ss][Ee]|[Ff][Oo][Rr][Mm]))[\s\S]*>\Z" foldEnd="&lt;\s*/\s*(?i)(?#see-insert-start-group:cfmltagstatename)\s*>" foldable="yes" usespellchecking="yes" scope="meta.block.tag">
				
				<import mode="XML" keywords-only="yes"/>
                <import keywords-only="yes"/>
				<import state="CFML Output Variables State" keywords-only="yes"/>
				<import/>
			</state>

			<state id="CFML Tags" foldable="no" foldState="Foldable CFML Tags" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" scope="markup.tag.framework">
				<begin><regex>&lt;(?i)/?cf</regex></begin>
				<end><regex>&gt;</regex></end>
				
				<import state="CFML Code" />
				<import state="Tags"/>
				
				<keywords id="Attributes in CFML Tags" useforautocomplete="no" scope="markup.tag.attribute.name">
					<regex>([\w-]*)(?=[ \t]*=)</regex>
				</keywords>

			</state>

            <state id="Foldable Tags" containerState="yes" delimiterState="Tags" 
            foldBegin="\A&lt;[ \t]*(?'xmltagstatename'(?i:(?:a(?:rticle|side|udio))|(?:h(?:ead|eader|tml|\d|group))|(?:b(?:ody|lockquote))|p|pre|a|(?:t(?:able|head|body|foot|h|d|r))|div|(?:f(?:ieldset|orm|ooter))|ul|ol|li|dl|(?:s(?:ection|elect|ource))|nav|ruby|video))\b[\s\S]*(?&lt;![/?])>\Z" foldEnd="&lt;\s*/\s*(?i)(?#see-insert-start-group:xmltagstatename)\s*>" foldable="yes" usespellchecking="yes" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" scope="meta.block.tag">
				
				<import mode="XML" keywords-only="yes"/>
                <import keywords-only="yes"/>
				<import state="CFML Output Variables State" keywords-only="yes"/>
				<import/>
			</state>

			<state id="Tags" usespellchecking="no" foldState="Foldable Tags" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" scope="markup.tag">
                <begin>
                    <regex>&lt;</regex>
                </begin>
                <end>
                    <regex>&gt;</regex>
                </end>
                
                <state id="CFML Tags in HTML Tags" foldable="no" usesymbolsfrommode="CFML" useautocompletefrommode="CFML" scope="markup.tag.framework">
					<begin><regex>&lt;(?i)/?cf</regex></begin>
					<end><regex>&gt;</regex></end>
					
					<import state="CFML Tags" />
				</state>
				
				<import state="CFML Output Variables State" keywords-only="yes"/>
                
                <state id="Javascript Actions" usesymbolsfrommode="JavaScript" useautocompletefrommode="JavaScript" scope="meta.default" >
					<begin><regex>(?&lt;=[ \t])(?i)on[\w]+[ \t]*=[ \t]*"</regex></begin>
					<end><regex>"</regex></end>
	                <keywords id="Action Attribute" useforautocomplete="no" scope="markup.tag.attribute.name">
						<regex>\A([\w-]+)[ \t]*=</regex>
					</keywords>
					
					<keywords id="Action Quotes" useforautocomplete="no" scope="markup.tag.attribute.value.string">
						<regex>(")</regex>
					</keywords>
					
					<keywords id="Action Equals" useforautocomplete="no" scope="markup.tag">
						<regex>\A(?i)on[\w-]+([ \t]*=[ \t]*)</regex>
					</keywords>
					<import mode="JavaScript" keywords-only="yes"/>
	                <import state="JavaScript Container"/>
					<import state="CFML Output Variables State" keywords-only="yes"/>
            	</state>
            	
            	<state id="Links" type="url" scope="meta.link">
					<begin><regex>(?&lt;=[ \t])(?i)(?:href|src)[ \t]*=[ \t]*"</regex></begin>
					<end><regex>"</regex></end>

					<import state="CFML Output Variables State" keywords-only="yes"/>

					<state id="Javascript in Links" usesymbolsfrommode="JavaScript" useautocompletefrommode="JavaScript" scope="meta.block.js">
						<begin><regex>\A[ \t]*(?i)javascript:</regex></begin>
						<end><regex>(?'unwindend'")</regex></end>
						<import mode="JavaScript" keywords-only="yes"/>
	                	<import state="JavaScript Container"/>
   						<import state="CFML Output Variables State" keywords-only="yes"/>
	                </state>
					
					<keywords id="Link Attribute" useforautocomplete="no" scope="markup.tag.attribute.name">
						<regex>\A(\w+)[ \t]*=</regex>
					</keywords>
					
					<keywords id="Link Quotes" useforautocomplete="no" scope="markup.tag.attribute.value.string">
						<regex>(")</regex>
					</keywords>
					
					<keywords id="Link Equals" useforautocomplete="no" scope="markup.tag">
						<regex>\A(?i)\w+([ \t]*=[ \t]*)</regex>
					</keywords>
					
				</state>
            	
               	<state id="Strings in Tags" type="string" useforautocomplete="no" scope="markup.tag.attribute.value.string">
					<begin><regex>"</regex></begin>
					<end><regex>"</regex></end>

   					<import state="CFML Output Variables State" keywords-only="yes" />

					<state id="CFML Tags in HTML Strings" foldable="no" scope="markup.tag">
						<begin><regex>&lt;(?=(?i)/?cf)</regex></begin>
						<end><regex>&gt;</regex></end>
						
						<import state="CFML Tags" />
					</state>
				</state>
				
				<state id="Single Strings in Tags" type="string" useforautocomplete="no" scope="markup.tag.attribute.value.string">
					<begin><regex>'</regex></begin>
					<end><regex>'</regex></end>
					
   					<import state="CFML Output Variables State" keywords-only="yes" />
					<import state="Strings in Tags"/>
				</state>
				
				<keywords id="Attributes in Tags" useforautocomplete="no" scope="markup.tag.attribute.name">
					<regex>([\w-]*)(?=[ \t]*=)</regex>
				</keywords>
            </state>

	</default>

</states>

</syntax>